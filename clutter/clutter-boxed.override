%%
ignore
  clutter_knot_free
%%
override clutter_geometry_new kwargs
static int
_wrap_clutter_geometry_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", "width", "height", NULL };
	ClutterGeometry geom = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterGeometry.__init__",
					 kwlist,
					 &(geom.x), &(geom.y),
					 &(geom.width), &(geom.height)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_GEOMETRY, &geom);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_GEOMETRY;
	
	return 0;
}
%%
override-slot ClutterGeometry.tp_as_sequence
static int
_wrap_clutter_geometry_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_geometry_getitem (PyGBoxed *self, Py_ssize_t pos)
{
	ClutterGeometry *geom;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	switch (pos) {
		case 0: return PyInt_FromLong (geom->x);
		case 1: return PyInt_FromLong (geom->y);
		case 2: return PyInt_FromLong (geom->width);
		case 3: return PyInt_FromLong (geom->height);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_geometry_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterGeometry *geom;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: geom->x      = val; break;
		case 1: geom->y      = val; break;
		case 2: geom->width  = val; break;
		case 3: geom->height = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_geometry_tp_as_sequence = {
	(lenfunc) _wrap_clutter_geometry_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_geometry_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_geometry_setitem,
        0
};
%%
override-attr ClutterGeometry.x
static int
_wrap_clutter_geometry__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->x = val;

	return 0;
}
%%
override-attr ClutterGeometry.y
static int
_wrap_clutter_geometry__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->y = val;

	return 0;
}
%%
override-attr ClutterGeometry.width
static int
_wrap_clutter_geometry__set_width (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterGeometry)->width = val;
	
	return 0;
}
%%
override-attr ClutterGeometry.height
static int
_wrap_clutter_geometry__set_height (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterGeometry)->height = val;

	return 0;
}
%%
override clutter_actor_box_new kwargs
static int
_wrap_clutter_actor_box_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x1", "y1", "x2", "y2", NULL };
	ClutterActorBox box = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterActorBox.__init__",
					 kwlist,
					 &(box.x1), &(box.y1),
					 &(box.x2), &(box.y2)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_ACTOR_BOX, &box);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_ACTOR_BOX;
	
	return 0;
}
%%
override-slot ClutterActorBox.tp_as_sequence
static int
_wrap_clutter_actor_box_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_actor_box_getitem(PyGBoxed *self, int pos)
{
	ClutterActorBox *box;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	switch (pos) {
		case 0: return PyInt_FromLong (box->x1);
		case 1: return PyInt_FromLong (box->y1);
		case 2: return PyInt_FromLong (box->x2);
		case 3: return PyInt_FromLong (box->y2);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_actor_box_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterActorBox *box;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: box->x1 = val; break;
		case 1: box->y1 = val; break;
		case 2: box->x2 = val; break;
		case 3: box->y2 = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_actor_box_tp_as_sequence = {
	(lenfunc) _wrap_clutter_actor_box_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_actor_box_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_actor_box_setitem,
	0
};
%%
override-attr ClutterActorBox.x1
static int
_wrap_clutter_actor_box__set_x1 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->x1 = val;

	return 0;
}
%%
override-attr ClutterActorBox.y1
static int
_wrap_clutter_actor_box__set_y1 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->y1 = val;

	return 0;
}
%%
override-attr ClutterActorBox.x2
static int
_wrap_clutter_actor_box__set_x2 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterActorBox)->x2 = val;
	
	return 0;
}
%%
override-attr ClutterActorBox.y2
static int
_wrap_clutter_actor_box__set_y2 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterActorBox)->y2 = val;

	return 0;
}
%%
override clutter_knot_new kwargs
static int
_wrap_clutter_knot_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", NULL };
	ClutterKnot knot = { 0, 0, };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|ii:ClutterKnot.__init__",
					 kwlist,
					 &(knot.x), &(knot.y)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_KNOT, &knot);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_KNOT;
	
	return 0;
}
%%
override-slot ClutterKnot.tp_as_sequence
static int
_wrap_clutter_knot_length (PyGBoxed *self)
{
	return 2;
}
static PyObject *
_wrap_clutter_knot_getitem(PyGBoxed *self, int pos)
{
	ClutterKnot *knot;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 2) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	knot = pyg_boxed_get (self, ClutterKnot);
	switch (pos) {
		case 0: return PyInt_FromLong (knot->x);
		case 1: return PyInt_FromLong (knot->y);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_knot_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterKnot *knot;
	gint val;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 2) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	knot = pyg_boxed_get (self, ClutterKnot);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: knot->x = val; break;
		case 1: knot->y = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_knot_tp_as_sequence = {
	(lenfunc) _wrap_clutter_knot_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_knot_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_knot_setitem,
	0
};
%%
override-attr ClutterKnot.x
static int
_wrap_clutter_knot__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterKnot)->x = val;

	return 0;
}
%%
override-attr ClutterKnot.y
static int
_wrap_clutter_knot__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterKnot)->y = val;

	return 0;
}
%%
override clutter_vertex_new kwargs
static int
_wrap_clutter_vertex_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", "z", NULL };
	ClutterVertex vertex = { 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iii:ClutterVertex.__init__",
					 kwlist,
					 &(vertex.x), &(vertex.y), &(vertex.z)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_VERTEX, &vertex);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_VERTEX;
	
	return 0;
}
%%
override-slot ClutterVertex.tp_as_sequence
static Py_ssize_t
_wrap_clutter_vertex_length (PyGBoxed *self)
{
	return 3;
}
static PyObject *
_wrap_clutter_vertex_getitem(PyGBoxed *self, Py_ssize_t pos)
{
	ClutterVertex *vertex;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	vertex = pyg_boxed_get (self, ClutterVertex);
	switch (pos) {
		case 0: return PyInt_FromLong (vertex->x);
		case 1: return PyInt_FromLong (vertex->y);
		case 2: return PyInt_FromLong (vertex->z);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static Py_ssize_t
_wrap_clutter_vertex_setitem (PyGBoxed *self, Py_ssize_t pos, PyObject *value)
{
	ClutterVertex *vertex;
	gint val;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	vertex = pyg_boxed_get (self, ClutterVertex);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: vertex->x = val; break;
		case 1: vertex->y = val; break;
		case 2: vertex->z = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_vertex_tp_as_sequence = {
	(lenfunc) _wrap_clutter_vertex_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_vertex_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_vertex_setitem,
	0
};
%%
override-attr ClutterVertex.x
static int
_wrap_clutter_vertex__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVertex)->x = val;

	return 0;
}
%%
override-attr ClutterVertex.y
static int
_wrap_clutter_vertex__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVertex)->y = val;

	return 0;
}
%%
override-attr ClutterVertex.z
static int
_wrap_clutter_vertex__set_z (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVertex)->z = val;

	return 0;
}
%%
override clutter_margin_new kwargs
static int
_wrap_clutter_margin_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "top", "right", "bottom", "left", NULL };
	ClutterMargin margin = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterMargin.__init__",
					 kwlist,
					 &(margin.top),
                                         &(margin.right),
                                         &(margin.bottom),
                                         &(margin.left)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_MARGIN, &margin);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_MARGIN;
	
	return 0;
}
%%
override-slot ClutterMargin.tp_as_sequence
static Py_ssize_t
_wrap_clutter_margin_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_margin_getitem(PyGBoxed *self, Py_ssize_t pos)
{
	ClutterMargin *margin;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	margin = pyg_boxed_get (self, ClutterMargin);
	switch (pos) {
		case 0: return PyInt_FromLong (margin->top);
		case 1: return PyInt_FromLong (margin->right);
		case 2: return PyInt_FromLong (margin->bottom);
		case 3: return PyInt_FromLong (margin->left);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static Py_ssize_t
_wrap_clutter_margin_setitem (PyGBoxed *self, Py_ssize_t pos, PyObject *value)
{
	ClutterMargin *margin;
	gint val;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	margin = pyg_boxed_get (self, ClutterMargin);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: margin->top = val; break;
		case 1: margin->right = val; break;
		case 2: margin->bottom = val; break;
		case 3: margin->left = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_margin_tp_as_sequence = {
	(lenfunc) _wrap_clutter_margin_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_margin_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_margin_setitem,
	0
};
%%
override-attr ClutterMargin.top
static int
_wrap_clutter_margin__set_top (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterMargin)->top = val;

	return 0;
}
%%
override-attr ClutterMargin.right
static int
_wrap_clutter_margin__set_right (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterMargin)->right = val;

	return 0;
}
%%
override-attr ClutterMargin.bottom
static int
_wrap_clutter_margin__set_bottom (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterMargin)->bottom = val;

	return 0;
}
%%
override-attr ClutterMargin.left
static int
_wrap_clutter_margin__set_left (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterMargin)->left = val;

	return 0;
}
%%
override clutter_padding_new kwargs
static int
_wrap_clutter_padding_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "top", "right", "bottom", "left", NULL };
	ClutterPadding padding = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterPadding.__init__",
					 kwlist,
					 &(padding.top),
                                         &(padding.right),
                                         &(padding.bottom),
                                         &(padding.left)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_PADDING, &padding);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_PADDING;
	
	return 0;
}
%%
override-slot ClutterPadding.tp_as_sequence
static Py_ssize_t
_wrap_clutter_padding_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_padding_getitem(PyGBoxed *self, Py_ssize_t pos)
{
	ClutterPadding *padding;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	padding = pyg_boxed_get (self, ClutterPadding);
	switch (pos) {
		case 0: return PyInt_FromLong (padding->top);
		case 1: return PyInt_FromLong (padding->right);
		case 2: return PyInt_FromLong (padding->bottom);
		case 3: return PyInt_FromLong (padding->left);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static Py_ssize_t
_wrap_clutter_padding_setitem (PyGBoxed *self, Py_ssize_t pos, PyObject *value)
{
	ClutterPadding *padding;
	gint val;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	padding = pyg_boxed_get (self, ClutterPadding);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: padding->top = val; break;
		case 1: padding->right = val; break;
		case 2: padding->bottom = val; break;
		case 3: padding->left = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_padding_tp_as_sequence = {
	(lenfunc) _wrap_clutter_padding_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_padding_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_padding_setitem,
	0
};
%%
override-attr ClutterPadding.top
static int
_wrap_clutter_padding__set_top (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterPadding)->top = val;

	return 0;
}
%%
override-attr ClutterPadding.right
static int
_wrap_clutter_padding__set_right (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterPadding)->right = val;

	return 0;
}
%%
override-attr ClutterPadding.bottom
static int
_wrap_clutter_padding__set_bottom (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterPadding)->bottom = val;

	return 0;
}
%%
override-attr ClutterPadding.left
static int
_wrap_clutter_padding__set_left (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterPadding)->left = val;

	return 0;
}
