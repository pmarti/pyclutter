/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include "pyclutter.h"
%%
include
  clutter-actor.override
  clutter-behaviour.override
  clutter-boxed.override
  clutter-color.override
  clutter-event.override
%%
modulename clutter
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type
%%
ignore
  clutter_init_with_args
  clutter_backend_get_event
  clutter_backend_put_event
  clutter_backend_peek_event
  clutter_get_option_group
  clutter_rectangle_new_with_color
  clutter_stage_set_perspectivex
  clutter_stage_get_perspectivex
  clutter_container_add_actor
  clutter_container_add_valist
  clutter_container_remove_actor
  clutter_container_remove_valist
  clutter_effect_template_new
  clutter_effect_template_new_full
  clutter_effect_depth
  clutter_effect_fade
  clutter_effect_move
  clutter_effect_scale
  clutter_effect_rotate_x
  clutter_effect_rotate_y
  clutter_effect_rotate_z
  clutter_layout_tune_request
%%
ignore-glob
  *_quark
  *_get_type
  _*
%%
override clutter_init noargs
static PyObject *
_wrap_clutter_init (PyObject *self, PyObject *args)
{
    PyObject *av;
    int argc, i;
    char **argv;
    
    /* initialise Clutter... */
    av = PySys_GetObject("argv");
    if (av != NULL) {
	if (!PyList_Check(av)) {
	    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
	    av = NULL;
	} else {
	    argc = PyList_Size(av);
	    for (i = 0; i < argc; i++)
		if (!PyString_Check(PyList_GetItem(av, i))) {
		    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
		    av = NULL;
		    break;
		}
	}
    }
    if (av != NULL) {
	argv = g_new(char *, argc);
	for (i = 0; i < argc; i++)
	    argv[i] = g_strdup(PyString_AsString(PyList_GetItem(av, i)));
    } else {
	    argc = 0;
	    argv = NULL;
    }

    if (!clutter_init (&argc, &argv)) {
	if (argv != NULL) {
	    for (i = 0; i < argc; i++)
		g_free(argv[i]);
	    g_free(argv);
	}
	PyErr_SetString(PyExc_RuntimeError, "could not open display");
	/* set the LC_NUMERIC locale back to "C", as Python < 2.4 requires
	 * that it be set that way. */
#if PY_VERSION_HEX < 0x020400F0
	setlocale(LC_NUMERIC, "C");
#endif
	return NULL;
    }
    /* set the LC_NUMERIC locale back to "C", as Python < 2.4 requires that
     * it be set that way. */
#if PY_VERSION_HEX < 0x020400F0
    setlocale(LC_NUMERIC, "C");
#endif
    if (argv != NULL) {
	PySys_SetArgv(argc, argv);
	for (i = 0; i < argc; i++)
	    g_free(argv[i]);
	g_free(argv);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override clutter_texture_get_base_size
static PyObject *
_wrap_clutter_texture_get_base_size (PyGObject *self)
{
	gint width, height;

	clutter_texture_get_base_size (CLUTTER_TEXTURE (self->obj),
				       &width,
				       &height);
	return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_texture_get_n_tiles
static PyObject *
_wrap_clutter_texture_get_n_tiles (PyGObject *self)
{
	gint n_x_tiles, n_y_tiles;

	clutter_texture_get_n_tiles (CLUTTER_TEXTURE (self->obj),
				     &n_x_tiles,
				     &n_y_tiles);
	return Py_BuildValue ("(ii)", n_x_tiles, n_y_tiles);
}
%%
override clutter_texture_get_x_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_x_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "x_index", NULL };
	gint x_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_x_tile_detail",
					  kwlist, &x_index))
		return NULL;
	
	clutter_texture_get_x_tile_detail (CLUTTER_TEXTURE (self->obj),
					   x_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_texture_get_y_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_y_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "y_index", NULL };
	gint y_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_y_tile_detail",
					  kwlist, &y_index))
		return NULL;
	
	clutter_texture_get_y_tile_detail (CLUTTER_TEXTURE (self->obj),
					   y_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_container_add
static PyObject *
_wrap_clutter_container_add (PyGObject *self,
                             PyObject  *args)
{
	ClutterContainer *container;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	container = CLUTTER_CONTAINER (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_container_add_actor (container, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_container_remove
static PyObject *
_wrap_clutter_container_remove (PyGObject *self,
                                PyObject  *args)
{
	ClutterContainer *container;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	container = CLUTTER_CONTAINER (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_container_remove_actor (container, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main noargs
static PyObject *
_wrap_clutter_main (PyObject *self)
{
	pyg_begin_allow_threads;
	clutter_main ();
	pyg_end_allow_threads;

	if (PyErr_Occurred ())
		return NULL;
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main_quit
static PyObject *
_wrap_clutter_main_quit (PyObject *self, PyObject *args)
{
	/* sanity check to make sure we are in a main loop */
	if (clutter_main_level () == 0) {
		PyErr_SetString (PyExc_RuntimeError,
				 "called outside of a mainloop");
		return NULL;
	}

	clutter_main_quit ();
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_stage_set_color kwargs
static PyObject *
_wrap_clutter_stage_set_color (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterStage.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_stage_set_color (CLUTTER_STAGE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_stage_get_color noargs
static PyObject *
_wrap_clutter_stage_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_stage_get_color (CLUTTER_STAGE (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);	
}
%%
override clutter_rectangle_set_color kwargs
static PyObject *
_wrap_clutter_rectangle_set_color (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color = { 0, };

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterRectangle.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_rectangle_set_color (CLUTTER_RECTANGLE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_rectangle_get_color noargs
static PyObject *
_wrap_clutter_rectangle_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_rectangle_get_color (CLUTTER_RECTANGLE (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_rectangle_set_border_color kwargs
static PyObject *
_wrap_clutter_rectangle_set_border_color (PyGObject *self,
                                          PyObject  *args,
                                          PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterRectangle.set_border_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_rectangle_set_border_color (CLUTTER_RECTANGLE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_rectangle_get_border_color noargs
static PyObject *
_wrap_clutter_rectangle_get_border_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_rectangle_get_border_color (CLUTTER_RECTANGLE (self->obj),
                                            &color);
	
        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_label_set_color kwargs
static PyObject *
_wrap_clutter_label_set_color (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterLabel.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_label_set_color (CLUTTER_LABEL (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_label_get_color noargs
static PyObject *
_wrap_clutter_label_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_label_get_color (CLUTTER_LABEL (self->obj), &color);
	
        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_box_set_color kwargs
static PyObject *
_wrap_clutter_box_set_color (PyGObject *self,
                             PyObject  *args,
                             PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterBox.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyclutter_color_from_pyobject (py_color, &color)) {
                PyErr_Clear ();
                PyErr_SetString (PyExc_TypeError,
                                 "color must be a ClutterColor or 4-tuple");
                return NULL;
        }

        clutter_box_set_color (CLUTTER_BOX (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_box_get_color noargs
static PyObject *
_wrap_clutter_box_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_box_get_color (CLUTTER_BOX (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);	
}
%%
override clutter_box_set_margin kwargs
static PyObject *
_wrap_clutter_box_set_margin (PyGObject *self,
                              PyObject  *args,
                              PyObject  *kwargs)
{
        static char *kwlist[] = { "margin", NULL };
        PyObject *py_margin;
        ClutterMargin margin;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterBox.set_margin", kwlist,
                                          &py_margin)) {
                return NULL;
        }

        if (!pyclutter_margin_from_pyobject (py_margin, &margin)) {
                PyErr_Clear ();
                PyErr_SetString (PyExc_TypeError,
                                 "color must be a ClutterColor or 4-tuple");
                return NULL;
        }

        clutter_box_set_margin (CLUTTER_BOX (self->obj), &margin);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_box_get_margin noargs
static PyObject *
_wrap_clutter_box_get_margin (PyGObject *self)
{
	ClutterMargin margin = { 0, };

	clutter_box_get_margin (CLUTTER_BOX (self->obj), &margin);

        return pyg_boxed_new (CLUTTER_TYPE_MARGIN, &margin, TRUE, TRUE);	
}
%%
override clutter_container_foreach kwargs
static void
pyclutter_container_foreach (ClutterActor *actor,
                             gpointer      data)
{
        PyClutterCallback *pycb = data;
        PyGILState_STATE state;
        PyObject *py_actor;
        PyObject *retobj;

        state = pyg_gil_state_ensure ();

        py_actor = pygobject_new ((GObject *) actor);
        retobj = pyclutter_callback_invoke (pycb, py_actor);
        if (retobj == NULL)
                PyErr_Print ();

        Py_XDECREF (retobj);

        pyg_gil_state_release (state);
}
static PyObject *
_wrap_clutter_container_foreach (PyGObject *self,
                                 PyObject  *args,
                                 PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        ClutterContainer *container;
        PyClutterCallback *pycb;
        GType param_types[] = { CLUTTER_TYPE_ACTOR, };

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Container.foreach",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       1, param_types);

        container = CLUTTER_CONTAINER (self->obj);
        clutter_container_foreach (container, pyclutter_container_foreach, pycb);

        pyclutter_callback_free (pycb);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_container_get_children noargs
static PyObject *
_wrap_clutter_container_get_children (PyGObject *self)
{
        GList *children, *l;
        PyObject *py_list;

        children = clutter_container_get_children (CLUTTER_CONTAINER (self->obj));

        if ((py_list = PyList_New (0)) == NULL) {
                g_list_free (children);
                return NULL;
        }

        for (l = children; l != NULL; l = l->next) {
                ClutterActor *actor = l->data;
                PyObject *py_actor;

                py_actor = pygobject_new ((GObject *) actor);
                if (!py_actor) {
                        g_list_free (children);
                        Py_DECREF (py_list);
                        return NULL;
                }

                PyList_Append (py_list, py_actor);
                Py_DECREF (py_actor);
        }

        g_list_free (children);

        return py_list;
}
%%
override clutter_entry_handle_key_event
static PyObject *
_wrap_clutter_entry_handle_key_event (PyGObject *self, PyObject *args)
{
        ClutterKeyEvent *key_event;

        key_event = (ClutterKeyEvent *) pyg_boxed_get (args, ClutterEvent);
        clutter_entry_handle_key_event (CLUTTER_ENTRY (self->obj), key_event);
        
        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_stage_get_perspective noargs
static PyObject *
_wrap_clutter_stage_get_perspective (PyGObject *self)
{
        gfloat fovy, aspect, z_near, z_far;

        clutter_stage_get_perspective (CLUTTER_STAGE (self->obj),
                                       &fovy, &aspect, &z_near, &z_far);

        return Py_BuildValue ("(ffff)", fovy, aspect, z_near, z_far);
}
%%
override clutter_layout_width_for_height
static PyObject *
_wrap_clutter_layout_width_for_height (PyGObject *self, PyObject *args)
{
        gint width, height;

        if (!PyInt_Check (args)) {
                PyErr_SetString (PyExc_TypeError, "Expected an integer");
                return NULL;
        }

        height = PyInt_AsLong (args);
        clutter_layout_width_for_height (CLUTTER_LAYOUT (self), &width, height);

        return PyInt_FromLong (width);
}
%%
override ClutterLayout__proxy_do_width_for_height
static void
_wrap_ClutterLayout__proxy_do_width_for_height (ClutterLayout *self,
                                                gint32        *width,
                                                gint32         height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_args;
    PyObject *py_height;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }

    py_height = PyInt_FromLong(height);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_height);
    
    py_method = PyObject_GetAttrString(py_self, "do_width_for_height");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }

    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (!PyInt_Check(py_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    if (width)
      *width = PyInt_AsLong(py_retval);
    
    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return;
}
%%
override clutter_layout_height_for_width
static PyObject *
_wrap_clutter_layout_height_for_width (PyGObject *self, PyObject *args)
{
        gint width, height;

        if (!PyInt_Check (args)) {
                PyErr_SetString (PyExc_TypeError, "Expected an integer");
                return NULL;
        }

        width = PyInt_AsLong (args);
        clutter_layout_height_for_width (CLUTTER_LAYOUT (self), width, &height);

        return PyInt_FromLong (height);
}
%%
override ClutterLayout__proxy_do_height_for_width
static void
_wrap_ClutterLayout__proxy_do_height_for_width (ClutterLayout *self,
                                                gint32         width,
                                                gint32        *height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_args;
    PyObject *py_width;
    PyObject *py_retval;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }

    py_width = PyInt_FromLong(width);
    
    py_args = PyTuple_New(1);
    PyTuple_SET_ITEM(py_args, 0, py_width);
    
    py_method = PyObject_GetAttrString(py_self, "do_height_for_width");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (!PyInt_Check (py_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    
    if (height)
      *height = PyInt_AsLong (py_retval);
    
    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return;
}
%%
override clutter_layout_natural_request noargs
static PyObject *
_wrap_clutter_layout_natural_request (PyGObject *self)
{
        gint width, height;

        clutter_layout_natural_request (CLUTTER_LAYOUT (self),
                                        &width, &height);

        return Py_BuildValue ("(ii)", width, height);
}
%%
override ClutterLayout__proxy_do_natural_request
static void
_wrap_ClutterLayout__proxy_do_natural_request (ClutterLayout *self,
                                               gint32        *width,
                                               gint32        *height)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    gint32 my_width, my_height;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }

    py_method = PyObject_GetAttrString(py_self, "do_width_for_height");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (!PyArg_ParseTuple(py_retval, "ii", &my_width, &my_height)) {
	PyErr_Print();
	Py_DECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);
	return;
    }
    
    if (width)
      *width = my_width;
    if (height)
      *height = my_height;
    
    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
    
    return;
}
%%
override ClutterLayout__do_width_for_height kwargs
static PyObject *
_wrap_ClutterLayout__do_width_for_height (PyObject *cls,
                                          PyObject *args,
                                          PyObject *kwargs)
{
        ClutterLayoutIface *iface;
        static char *kwlist[] = { "self", "height", NULL };
        PyGObject *self;
        gint32 height, width;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "Oi:ClutterLayout.height_for_width",
                                          kwlist,
                                          &PyClutterBehaviour_Type, &self, &height))
                return NULL;
        
        iface = g_type_interface_peek (g_type_class_peek (pyg_type_from_object (cls)), CLUTTER_TYPE_LAYOUT);
        if (iface->width_for_height) {
          iface->width_for_height (CLUTTER_LAYOUT (self->obj), &width, height);
        }
        else {
                PyErr_SetString (PyExc_NotImplementedError,
                                 "interface method ClutterLayout.width_for_height not implemented");
                return NULL;
        }

        return PyInt_FromLong (width);
}
%%
override ClutterLayout__do_height_for_width kwargs
static PyObject *
_wrap_ClutterLayout__do_height_for_width (PyObject *cls,
                                          PyObject *args,
                                          PyObject *kwargs)
{
        ClutterLayoutIface *iface;
        static char *kwlist[] = { "self", "width", NULL };
        PyGObject *self;
        gint32 height, width;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "Oi:ClutterLayout.height_for_width",
                                          kwlist,
                                          &PyClutterBehaviour_Type, &self, &width))
                return NULL;

        iface = g_type_interface_peek (g_type_class_peek (pyg_type_from_object (cls)), CLUTTER_TYPE_LAYOUT);
        if (iface->height_for_width) {
          iface->height_for_width (CLUTTER_LAYOUT (self->obj), width, &height);
        }
        else {
                PyErr_SetString (PyExc_NotImplementedError,
                                 "interface method ClutterLayout.height_for_width not implemented");
                return NULL;
        }

        return PyInt_FromLong (height);
}
%%
override ClutterLayout__do_natural_request kwargs
static PyObject *
_wrap_ClutterLayout__do_natural_request (PyObject *cls,
                                         PyObject *args,
                                         PyObject *kwargs)
{
        ClutterLayoutIface *iface;
        static char *kwlist[] = { "self", NULL };
        PyGObject *self;
        gint32 height, width;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O!:ClutterLayout.natural_request",
                                          kwlist,
                                          &PyClutterBehaviour_Type, &self))
                return NULL;

        iface = g_type_interface_peek (g_type_class_peek (pyg_type_from_object (cls)), CLUTTER_TYPE_LAYOUT);
        if (iface->natural_request) {
          iface->natural_request (CLUTTER_LAYOUT (self->obj), &width, &height);
        }
        else {
                PyErr_SetString (PyExc_NotImplementedError,
                                 "interface method ClutterLayout.natural_request not implemented");
                return NULL;
        }

        return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_box_get_default_padding noargs
static PyObject *
_wrap_clutter_box_get_default_padding (PyGObject *self)
{
  gint top, right, bottom, left;

  clutter_box_get_default_padding (CLUTTER_BOX (self->obj),
                                   &top, &right, &bottom, &left);

  return Py_BuildValue ("(iiii)", top, right, bottom, left);
}
%%
override clutter_box_query_child kwargs
static PyObject *
_wrap_clutter_box_query_child (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "actor", NULL };
        PyObject *py_actor;
        ClutterActor *actor;
        ClutterBoxChild query;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterBox.query_child", kwlist,
                                          &py_actor)) {
                return NULL;
        }

        if (!pygobject_check (py_actor, &PyClutterActor_Type)) {
                PyErr_Clear ();
                PyErr_SetString (PyExc_TypeError, "expecting a ClutterActor");
                return NULL;
        }
        else
                actor = CLUTTER_ACTOR (pygobject_get (py_actor));

        if (clutter_box_query_child (CLUTTER_BOX (self->obj), actor, &query))
                return pyclutter_box_child_to_pyobject (&query);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_box_query_nth_child kwargs
static PyObject *
_wrap_clutter_box_query_nth_child (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "index", NULL };
        gint index_;
        ClutterBoxChild query;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "i:ClutterBox.query_nth_child", kwlist,
                                          &index_)) {
                return NULL;
        }

        if (clutter_box_query_nth_child (CLUTTER_BOX (self->obj), index_, &query))
                return pyclutter_box_child_to_pyobject (&query);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_threads_init noargs
static PyObject *
_wrap_clutter_threads_init (PyObject *self)
{
        if (pyg_enable_threads ())
                return NULL;
        
        clutter_threads_init ();

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_threads_enter noargs
static PyObject *
_wrap_clutter_threads_enter (PyObject *self)
{
        /* must allow threads while acquiring lock, or no other python
         * code will execute while we wait
         */
        pyg_begin_allow_threads;
        clutter_threads_enter ();
        pyg_end_allow_threads;

        Py_INCREF (Py_None);
        return Py_None;
}
%%
