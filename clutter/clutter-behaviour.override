%%
ignore
  clutter_alpha_new_full
  clutter_behaviour_path_append_knot
  clutter_behaviour_path_append_knots_valist
  clutter_behaviour_bspline_append_knot
  clutter_behaviour_ellipse_newx
  clutter_behaviour_ellipse_set_angle_beginx
  clutter_behaviour_ellipse_get_angle_beginx
  clutter_behaviour_ellipse_set_angle_endx
  clutter_behaviour_ellipse_get_angle_endx
  clutter_behaviour_ellipse_set_angle_tiltx
  clutter_behaviour_ellipse_get_angle_tiltx
  clutter_behaviour_ellipse_set_tiltx
  clutter_behaviour_ellipse_get_tiltx
  clutter_behaviour_rotate_newx
  clutter_behaviour_rotate_set_boundsx
  clutter_behaviour_rotate_get_boundsx
  clutter_behaviour_scale_newx
  clutter_behaviour_scale_get_boundsx
%%
new-constructor CLUTTER_TYPE_ALPHA
%%
override clutter_alpha_new kwargs
static int
_wrap_clutter_alpha_new (PyGObject *self,
                         PyObject  *args,
                         PyObject  *kwargs)
{
        static char *kwlist[] = { "timeline", "func", "data", NULL };
        PyObject *py_timeline = Py_None;
        PyObject *py_func = Py_None;
        PyObject *py_data = Py_None;
        ClutterTimeline *timeline;
        PyClutterCallback *pycb;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|OOO:clutter.Alpha.__init__",
                                          kwlist,
                                          &py_timeline, &py_func, &py_data))
                return -1;

        if (py_timeline == Py_None)
                timeline = NULL;
        else if (pygobject_check (py_timeline, &PyClutterTimeline_Type))
                timeline = CLUTTER_TIMELINE (pygobject_get (py_timeline));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a timeline or None");
                return -1;
        }

        if (py_func == Py_None) {
                pygobject_construct (self, "timeline", timeline, NULL);
        }
        else {
                if (!PyCallable_Check (py_func)) {
                        PyErr_SetString(PyExc_TypeError,
                                        "func must be callable");
                        return -1;
                }
                else {
                        GType param_types[] = { CLUTTER_TYPE_ALPHA };
                        guint n_params = G_N_ELEMENTS (param_types);

                        pygobject_construct (self, "timeline", timeline, NULL);
                        if (!self->obj)
                                goto out;

                        pycb = pyclutter_callback_new (py_func, py_data,
                                                       n_params, param_types);
                        clutter_alpha_set_func (CLUTTER_ALPHA (self->obj),
                                                pyclutter_alpha_func,
                                                pycb,
                                                (GDestroyNotify) pyclutter_callback_free);
                }
        }

out:
        if (!self->obj) {
                PyErr_SetString (PyExc_RuntimeError,
                                 "could not create a ClutterAlpha object");
                return -1;
        }

        return 0;
                
}
%%
override clutter_alpha_set_func kwargs
static PyObject *
_wrap_clutter_alpha_set_func (PyGObject *self,
                              PyObject  *args,
                              PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        ClutterAlpha *alpha;
        PyClutterCallback *pycb;
        GType param_types[] = { CLUTTER_TYPE_ALPHA };
        gint n_params = G_N_ELEMENTS (param_types);

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Alpha.set_func",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       n_params, param_types);

        alpha = CLUTTER_ALPHA (self->obj);
        clutter_alpha_set_func (alpha,
                                pyclutter_alpha_func, pycb,
                                (GDestroyNotify) pyclutter_callback_free);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_behaviour_actors_foreach kwargs
static void
pyclutter_behaviour_foreach (ClutterBehaviour *behaviour,
                             ClutterActor     *actor,
                             gpointer          data)
{
        PyClutterCallback *pycb = data;
        PyGILState_STATE state;
        PyObject *py_behaviour, *py_actor;
        PyObject *retobj;

        state = pyg_gil_state_ensure ();

        py_behaviour = pygobject_new ((GObject *) behaviour);
        py_actor = pygobject_new ((GObject *) actor);
        retobj = pyclutter_callback_invoke (pycb, py_behaviour, py_actor);
        if (retobj == NULL)
                PyErr_Print ();

        Py_XDECREF (retobj);

        pyg_gil_state_release (state);
}
static PyObject *
_wrap_clutter_behaviour_actors_foreach (PyGObject *self,
                                        PyObject  *args,
                                        PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        ClutterBehaviour *behaviour;
        PyClutterCallback *pycb;
        GType param_types[] = {
                CLUTTER_TYPE_BEHAVIOUR,
                CLUTTER_TYPE_ALPHA,
        };
        gint n_params = G_N_ELEMENTS (param_types);

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Behaviour.actor_foreach",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       n_params, param_types);
        behaviour = CLUTTER_BEHAVIOUR (self->obj);

        clutter_behaviour_actors_foreach (behaviour,
                                          pyclutter_behaviour_foreach,
                                          pycb);

        pyclutter_callback_free (pycb);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_behaviour_get_actors
static PyObject *
_wrap_clutter_behaviour_get_actors (PyGObject *self,
                                    PyObject  *args)
{
        GSList *actors, *l;
        PyObject *py_list;

        actors = clutter_behaviour_get_actors (CLUTTER_BEHAVIOUR (self->obj));

        if ((py_list = PyList_New (0)) == NULL) {
                g_slist_free (actors);
                return NULL;
        }

        for (l = actors; l != NULL; l = l->next) {
                ClutterActor *actor = l->data;
                PyObject *py_actor;

                py_actor = pygobject_new ((GObject *) actor);
                if (!py_actor) {
                        g_slist_free (actors);
                        Py_DECREF (py_list);
                        return NULL;
                }

                PyList_Append (py_list, py_actor);
                Py_DECREF (py_actor);
        }

        g_slist_free (actors);

        return py_list;
}
%%
new-constructor CLUTTER_TYPE_BEHAVIOUR_PATH
%%
override clutter_behaviour_path_new kwargs
static int
_wrap_clutter_behaviour_path_new (PyGObject *self,
                                  PyObject  *args,
                                  PyObject  *kwargs)
{
        static char *kwlist[] = { "alpha", "knots", NULL};
        ClutterAlpha *alpha;
        PyObject *py_alpha = Py_None;
        PyObject *py_knots = Py_None;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|OO:clutter.BehaviourPath.__init__",
                                          kwlist, &py_alpha, &py_knots))
                return -1;
        
        if (py_alpha == Py_None)
                alpha = NULL;
        else if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
                alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a ClutterAlpha or None");
                return -1;
        }

        if (py_knots == Py_None)
                pygobject_construct (self, "alpha", alpha, NULL);
        else {
                guint n_knots, i;
                ClutterBehaviourPath *behaviour;
                
                if (PyTuple_Check (py_knots))
                        n_knots = PyTuple_Size (py_knots);
                else {
                        PyErr_SetString (PyExc_TypeError,
                                         "knots must be a tuple containing "
                                         "tuples of coordinates or None");
                        return -1;
                }

                if (pygobject_construct (self, "alpha", alpha, NULL)) {
                        goto out;
                }

                behaviour = CLUTTER_BEHAVIOUR_PATH (self->obj);

                for (i = 0; i < n_knots; i++) {
                        PyObject *py_knot;
                        ClutterKnot knot;

                        py_knot = PyTuple_GetItem (py_knots, i);
                        if (PyTuple_Check (py_knot) &&
                            PyTuple_Size (py_knot) == 2 &&
                            PyInt_Check (PyTuple_GetItem (py_knot, 0)) &&
                            PyInt_Check (PyTuple_GetItem (py_knot, 1))) {
                                knot.x = PyInt_AsLong (PyTuple_GetItem (py_knot, 0));
                                knot.y = PyInt_AsLong (PyTuple_GetItem (py_knot, 1));
                                clutter_behaviour_path_append_knot (behaviour,
                                                                    &knot);
                        }
                        else {
                                PyErr_SetString (PyExc_TypeError,
                                                 "expecting a tuple of two integers");
                                return -1;
                        }
                }
        }

out:
        if (!self->obj) {
                PyErr_SetString (PyExc_RuntimeError,
                                 "could not create a ClutterBehaviourPath object");
                return -1;
        }

        return 0;
}
%%
override clutter_behaviour_path_get_knots noargs
static PyObject *
_wrap_clutter_behaviour_path_get_knots (PyGObject *self)
{
        ClutterBehaviourPath *behaviour;
        GSList *knots, *l;
        PyObject *py_list;

        behaviour = CLUTTER_BEHAVIOUR_PATH (self->obj);
        knots = clutter_behaviour_path_get_knots (behaviour);

        if ((py_list = PyList_New (0)) == NULL) {
                g_slist_free (knots);
                return NULL;
        }

        for (l = knots; l != NULL; l = l->next) {
                ClutterKnot *knot = l->data;
                PyObject *py_knot;

                py_knot = pyg_boxed_new (CLUTTER_TYPE_KNOT, knot, TRUE, TRUE);
                if (!py_knot) {
                        g_slist_free (knots);
                        Py_DECREF (py_list);
                        return NULL;
                }

                PyList_Append (py_list, py_knot);
                Py_DECREF (py_knot);
        }

        g_slist_free (knots);

        return py_list;
}
%%
override clutter_behaviour_path_append_knots
static PyObject *
_wrap_clutter_behaviour_path_append_knots (PyGObject *self,
                                           PyObject  *args)
{
        ClutterBehaviourPath *pathb;
        int i, len;

        if ((len = PyTuple_Size (args)) < 1) {
                PyErr_SetString (PyExc_TypeError,
                                 "requires at least one argument");
                return NULL;
        }

        pathb = CLUTTER_BEHAVIOUR_PATH (self->obj);

        for (i = 0; i < len; i++) {
                PyObject *py_knot;
                ClutterKnot knot;

                py_knot = PyTuple_GetItem (args, i);

                if (!PyTuple_Check (py_knot) &&
                    PyTuple_Size (py_knot) != 2 &&
                    !PyInt_Check (PyTuple_GetItem (py_knot, 0)) &&
                    !PyInt_Check (PyTuple_GetItem (py_knot, 1))) {
                        PyErr_SetString (PyExc_TypeError,
                                         "expecting a tuple of two integers");
                        return NULL;
                }

                knot.x = PyInt_AsLong (PyTuple_GetItem (py_knot, 0));
                knot.y = PyInt_AsLong (PyTuple_GetItem (py_knot, 1));

                clutter_behaviour_path_append_knot (pathb, &knot);
        }

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override ClutterBehaviour__proxy_do_alpha_notify
static void
_wrap_ClutterBehaviour__proxy_do_alpha_notify (ClutterBehaviour *behaviour,
                                               guint32           alpha_value)
{
        PyGILState_STATE state;
        PyObject *py_self;
        PyObject *py_method, *py_args;
        PyObject *py_ret, *py_alpha;
        
        state = pyg_gil_state_ensure ();

        py_self = pygobject_new ((GObject *) behaviour);
        if (!py_self) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                pyg_gil_state_release (state);
                return;
        }

        py_alpha = PyLong_FromLong (alpha_value);
        if (!py_alpha) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                Py_DECREF (py_self);

                pyg_gil_state_release (state);
                return;
        }

        py_args = PyTuple_New (1);
        PyTuple_SET_ITEM (py_args, 0, py_alpha);

        py_method = PyObject_GetAttrString (py_self, "do_alpha_notify");
        if (!py_method) {
                if (PyErr_Occurred ())
                        PyErr_Print ();
                
                Py_DECREF (py_args);
                Py_DECREF (py_self);

                pyg_gil_state_release (state);
                return;
        }

        py_ret = PyObject_CallObject (py_method, py_args);
        if (!py_ret) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                Py_DECREF (py_method);
                Py_DECREF (py_args);
                Py_DECREF (py_self);

                pyg_gil_state_release (state);
                return;
        }
        
        if (py_ret != Py_None) {
                PyErr_SetString (PyExc_TypeError, "retval should be None");
                PyErr_Print();
                
                Py_DECREF (py_ret);
                Py_DECREF (py_method);
                Py_DECREF (py_args);
                Py_DECREF (py_self);
                
                pyg_gil_state_release (state);
                return;
        }

        Py_DECREF (py_ret);
        Py_DECREF (py_method);
        Py_DECREF (py_args);
        Py_DECREF (py_self);

        pyg_gil_state_release (state);
}
%%
override ClutterBehaviour__do_alpha_notify kwargs
static PyObject *
_wrap_ClutterBehaviour__do_alpha_notify (PyObject *cls,
                                         PyObject *args,
                                         PyObject *kwargs)
{
        gpointer klass;
        static char *kwlist[] = { "self", "alpha", NULL };
        PyGObject *self;
        PyObject *py_alpha;
        guint32 alpha_value = 0;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "OO:ClutterBehaviour.alpha_notify",
                                          kwlist,
                                          &PyClutterBehaviour_Type, &self,
                                          &py_alpha))
                return NULL;

        if (py_alpha) {
                if (PyLong_Check (py_alpha))
                        alpha_value = (guint32) PyLong_AsUnsignedLong (py_alpha);
                else if (PyInt_Check (py_alpha))
                        alpha_value = (guint32) PyInt_AsLong (py_alpha);
                else
                        PyErr_SetString (PyExc_TypeError,
                                         "Parameter 'alpha' must be an int or a long");

                if (PyErr_Occurred ())
                        return NULL;
        }

        klass = g_type_class_ref (pyg_type_from_object (cls));
        if (CLUTTER_BEHAVIOUR_CLASS (klass)->alpha_notify) {
                ClutterBehaviour *behaviour;
                
                behaviour = CLUTTER_BEHAVIOUR (self->obj);
                CLUTTER_BEHAVIOUR_CLASS (klass)->alpha_notify (behaviour,
                                                               alpha_value);
        }
        else {
                PyErr_SetString (PyExc_NotImplementedError,
                                 "virtual method ClutterBehaviour.alpha_notify not implemented");
                g_type_class_unref (klass);
                return NULL;
        }

        g_type_class_unref (klass);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
new-constructor CLUTTER_TYPE_BEHAVIOUR_BSPLINE
%%
override clutter_behaviour_bspline_new kwargs
static int
_wrap_clutter_behaviour_bspline_new (PyGObject *self,
                                     PyObject  *args,
                                     PyObject  *kwargs)
{
        static char *kwlist[] = { "alpha", "knots", NULL};
        ClutterAlpha *alpha;
        PyObject *py_alpha = Py_None;
        PyObject *py_knots = Py_None;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|OO:clutter.BehaviourBspline.__init__",
                                          kwlist, &py_alpha, &py_knots))
                return -1;
        
        if (py_alpha == Py_None)
                alpha = NULL;
        else if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
                alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a ClutterAlpha or None");
                return -1;
        }

        if (py_knots == Py_None)
                pygobject_construct (self, "alpha", alpha, NULL);
        else {
                guint n_knots, i;
                ClutterBehaviourBspline *behaviour;
                
                if (PyTuple_Check (py_knots))
                        n_knots = PyTuple_Size (py_knots);
                else {
                        PyErr_SetString (PyExc_TypeError,
                                         "knots must be a tuple containing "
                                         "tuples of coordinates or None");
                        return -1;
                }

                if (pygobject_construct (self, "alpha", alpha, NULL)) {
                        goto out;
                }

                behaviour = CLUTTER_BEHAVIOUR_BSPLINE (self->obj);

                for (i = 0; i < n_knots; i++) {
                        PyObject *py_knot;
                        ClutterKnot knot;

                        py_knot = PyTuple_GetItem (py_knots, i);
                        if (PyTuple_Check (py_knot) &&
                            PyTuple_Size (py_knot) == 2 &&
                            PyInt_Check (PyTuple_GetItem (py_knot, 0)) &&
                            PyInt_Check (PyTuple_GetItem (py_knot, 1))) {
                                knot.x = PyInt_AsLong (PyTuple_GetItem (py_knot, 0));
                                knot.y = PyInt_AsLong (PyTuple_GetItem (py_knot, 1));
                                clutter_behaviour_bspline_append_knot (behaviour,
                                                                       &knot);
                        }
                        else {
                                PyErr_SetString (PyExc_TypeError,
                                                 "expecting a tuple of two integers");
                                return -1;
                        }
                }
        }

out:
        if (!self->obj) {
                PyErr_SetString (PyExc_RuntimeError,
                                 "could not create a ClutterBehaviourBspline object");
                return -1;
        }

        return 0;
}
%%
override clutter_behaviour_bspline_append
static PyObject *
_wrap_clutter_behaviour_bspline_append (PyGObject *self,
                                        PyObject  *args)
{
        ClutterBehaviourBspline *bspline;
        int i, len;

        if ((len = PyTuple_Size (args)) < 1) {
                PyErr_SetString (PyExc_TypeError,
                                 "requires at least one argument");
                return NULL;
        }

        bspline = CLUTTER_BEHAVIOUR_BSPLINE (self->obj);

        for (i = 0; i < len; i++) {
                PyObject *py_knot;
                ClutterKnot knot;

                py_knot = PyTuple_GetItem (args, i);

                if (!PyTuple_Check (py_knot) &&
                    PyTuple_Size (py_knot) != 2 &&
                    !PyInt_Check (PyTuple_GetItem (py_knot, 0)) &&
                    !PyInt_Check (PyTuple_GetItem (py_knot, 1))) {
                        PyErr_SetString (PyExc_TypeError,
                                         "expecting a tuple of two integers");
                        return NULL;
                }

                knot.x = PyInt_AsLong (PyTuple_GetItem (py_knot, 0));
                knot.y = PyInt_AsLong (PyTuple_GetItem (py_knot, 1));

                clutter_behaviour_bspline_append_knot (bspline, &knot);
        }

        Py_INCREF (Py_None);
        return Py_None;
}
%%
new-constructor CLUTTER_TYPE_BEHAVIOUR_DEPTH
%%
override clutter_behaviour_depth_new kwargs
static int
_wrap_clutter_behaviour_depth_new (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "alpha", "depth_start", "depth_end", NULL};
        PyObject *py_alpha;
        int depth_start, depth_end;
        ClutterAlpha *alpha;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|Oii:clutter.BehaviourDepth.__init__",
                                          kwlist,
                                          &py_alpha, &depth_start, &depth_end))
                return -1;
        
        if (py_alpha == Py_None)
                alpha = NULL;
        else if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
                alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a ClutterAlpha or None");
                return -1;
        }

        pygobject_construct (self,
                             "alpha", alpha,
                             "start-depth", depth_start,
                             "end-depth", depth_end,
                             NULL);

        return 0;
}
%%
new-constructor CLUTTER_TYPE_BEHAVIOUR_ELLIPSE
%%
override clutter_behaviour_ellipse_new kwargs
static int
_wrap_clutter_behaviour_ellipse_new (PyGObject *self,
                                     PyObject  *args,
                                     PyObject  *kwargs)
{
        static char *kwlist[] = { "alpha", "x", "y", "width", "height", "begin", "end", NULL};
        PyObject *py_alpha;
        int x, y, width, height;
        double begin, end;
        ClutterKnot center = { 0, };
        ClutterAlpha *alpha;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|Oiiiidd:clutter.BehaviourEllipse.__init__",
                                          kwlist,
                                          &py_alpha, &x, &y, &width, &height,
                                          &begin, &end))
                return -1;
        
        if (py_alpha == Py_None)
                alpha = NULL;
        else if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
                alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a ClutterAlpha or None");
                return -1;
        }

        center.x = x;
        center.y = y;

        pygobject_construct (self,
                             "alpha", alpha,
                             "center", &center,
                             "width", width,
                             "height", height,
                             "angle-begin", begin,
                             "angle-end", end,
                             NULL);

        return 0;
}
%%
override clutter_behaviour_ellipse_get_center noargs
static PyObject *
_wrap_clutter_behaviour_ellipse_get_center (PyGObject *self)
{
        ClutterBehaviourEllipse *ellipse;
        gint center_x, center_y;

        ellipse = CLUTTER_BEHAVIOUR_ELLIPSE (self->obj);
        clutter_behaviour_ellipse_get_center (ellipse, &center_x, &center_y);

        return Py_BuildValue ("(ii)", center_x, center_y);
}
%%
override clutter_behaviour_ellipse_get_tilt noargs
static PyObject *
_wrap_clutter_behaviour_ellipse_get_tilt (PyGObject *self)
{
        ClutterBehaviourEllipse *ellipse;
        gdouble tilt_x, tilt_y, tilt_z;

        ellipse = CLUTTER_BEHAVIOUR_ELLIPSE (self->obj);
        clutter_behaviour_ellipse_get_tilt (ellipse, &tilt_x, &tilt_y, &tilt_z);

        return Py_BuildValue ("(ddd)", tilt_x, tilt_y, tilt_z);
}
%%
new-constructor CLUTTER_TYPE_BEHAVIOUR_OPACITY
%%
override clutter_behaviour_opacity_new kwargs
static int
_wrap_clutter_behaviour_opacity_new (PyGObject *self,
                                     PyObject  *args,
                                     PyObject  *kwargs)
{
        static char *kwlist[] = { "alpha", "begin", "end", NULL};
        PyObject *py_alpha;
        int begin, end;
        ClutterAlpha *alpha;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|Oii:clutter.BehaviourOpacity.__init__",
                                          kwlist,
                                          &py_alpha, &begin, &end))
                return -1;
        
        if (py_alpha == Py_None)
                alpha = NULL;
        else if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
                alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a ClutterAlpha or None");
                return -1;
        }

        pygobject_construct (self,
                             "alpha", alpha,
                             "opacity-start", begin,
                             "opacity-end", end,
                             NULL);

        return 0;
}
%%
%%
new-constructor CLUTTER_TYPE_BEHAVIOUR_ROTATE
%%
override clutter_behaviour_rotate_new kwargs
static int
_wrap_clutter_behaviour_rotate_new (PyGObject *self,
                                    PyObject  *args,
                                    PyObject  *kwargs)
{
        static char *kwlist[] = { "alpha", "axis", "direction", "begin", "end", NULL};
        PyObject *py_alpha;
        int axis, direction;
        double begin, end;
        ClutterAlpha *alpha;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|Oiidd:clutter.BehaviourRotate.__init__",
                                          kwlist,
                                          &py_alpha, &axis, &direction,
                                          &begin, &end))
                return -1;
        
        if (py_alpha == Py_None)
                alpha = NULL;
        else if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
                alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a ClutterAlpha or None");
                return -1;
        }

        pygobject_construct (self,
                             "alpha", alpha,
                             "axis", axis,
                             "direction", direction,
                             "angle-begin", begin,
                             "angle-end", end,
                             NULL);

        return 0;
}
%%
override clutter_behaviour_rotate_get_center noargs
static PyObject *
_wrap_clutter_behaviour_rotate_get_center (PyGObject *self)
{
        ClutterBehaviourRotate *rotate;
        gint center_x, center_y, center_z;

        rotate = CLUTTER_BEHAVIOUR_ROTATE (self->obj);
        clutter_behaviour_rotate_get_center (rotate, &center_x, &center_y, &center_z);

        return Py_BuildValue ("(iii)", center_x, center_y, center_z);
}
%%
override clutter_behaviour_rotate_get_bounds noargs
static PyObject *
_wrap_clutter_behaviour_rotate_get_bounds (PyGObject *self)
{
        ClutterBehaviourRotate *rotate;
        gdouble begin, end;

        rotate = CLUTTER_BEHAVIOUR_ROTATE (self->obj);
        clutter_behaviour_rotate_get_bounds (rotate, &begin, &end);

        return Py_BuildValue ("(dd)", begin, end);
}
%%
new-constructor CLUTTER_TYPE_BEHAVIOUR_SCALE
%%
override clutter_behaviour_scale_new kwargs
static int
_wrap_clutter_behaviour_scale_new (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "alpha", "begin", "end", "gravity", NULL};
        PyObject *py_alpha;
        double begin, end;
        ClutterGravity gravity;
        ClutterAlpha *alpha;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|Oddi:clutter.BehaviourScale.__init__",
                                          kwlist,
                                          &py_alpha, &begin, &end, &gravity))
                return -1;
        
        if (py_alpha == Py_None)
                alpha = NULL;
        else if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
                alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a ClutterAlpha or None");
                return -1;
        }

        pygobject_construct (self,
                             "alpha", alpha,
                             "scale-begin", begin,
                             "scale-end", end,
                             "scale-gravity", gravity,
                             NULL);

        return 0;
}
%%
override clutter_behaviour_scale_get_bounds noargs
static PyObject *
_wrap_clutter_behaviour_scale_get_bounds (PyGObject *self)
{
        ClutterBehaviourScale *scale;
        gdouble begin, end;

        scale = CLUTTER_BEHAVIOUR_SCALE (self->obj);
        clutter_behaviour_scale_get_bounds (scale, &begin, &end);

        return Py_BuildValue ("(dd)", begin, end);
}
%%
override clutter_ramp_inc_func
static PyObject *
_wrap_clutter_ramp_inc_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_ramp_inc_func (alpha, NULL));
          }
        
        return PyInt_FromLong (0);
}
%%
override clutter_ramp_dec_func
static PyObject *
_wrap_clutter_ramp_dec_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_ramp_dec_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_ramp_func
static PyObject *
_wrap_clutter_ramp_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_ramp_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_sine_inc_func
static PyObject *
_wrap_clutter_sine_inc_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_sine_inc_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_sine_dec_func
static PyObject *
_wrap_clutter_sine_dec_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_sine_dec_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_sine_half_func
static PyObject *
_wrap_clutter_sine_half_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_sine_half_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_sine_func
static PyObject *
_wrap_clutter_sine_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_sine_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_square_func
static PyObject *
_wrap_clutter_square_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_square_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_smoothstep_inc_func
static PyObject *
_wrap_clutter_smoothstep_inc_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_smoothstep_inc_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_smoothstep_dec_func
static PyObject *
_wrap_clutter_smoothstep_dec_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_smoothstep_dec_func (alpha, NULL));
          }
        
        return PyInt_FromLong (0);
}
%%
override clutter_exp_inc_func
static PyObject *
_wrap_clutter_exp_inc_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_exp_inc_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
override clutter_exp_dec_func
static PyObject *
_wrap_clutter_exp_dec_func (PyObject *self, PyObject *args)
{
        PyObject *py_alpha;
        ClutterAlpha *alpha;

        py_alpha = PyTuple_GetItem (args, 0);
        if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
          {
            alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
            return PyInt_FromLong (clutter_exp_dec_func (alpha, NULL));
          }

        return PyInt_FromLong (0);
}
%%
